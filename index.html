<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TSP Building Route Lab (Dramatic Classical vs Quantum Demo)</title>
  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 16px; }
    .row { display: flex; gap: 16px; align-items: flex-start; flex-wrap: wrap; }
    .panel { min-width: 320px; max-width: 420px; }
    button, input { padding: 8px 10px; margin: 4px 0; width: 100%; box-sizing: border-box; }
    textarea { width: 100%; height: 160px; box-sizing: border-box; }
    canvas { border: 1px solid #ccc; border-radius: 8px; }
    small { color: #444; display: block; line-height: 1.35; }
    .stat { padding: 10px 12px; background: #f5f5f5; border-radius: 8px; margin-top: 8px; }
    .hint { font-size: 12px; color: #555; margin-top: 6px; }
    .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .sectionTitle { margin-top: 12px; font-weight: 700; }
    .pill { display:inline-block; padding: 2px 8px; border-radius: 999px; background:#eee; font-size: 12px; }
    .dangerNote { font-size: 12px; color: #333; background: #fff7d6; border: 1px solid #ead48a; padding: 10px; border-radius: 8px; margin-top: 8px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
  </style>
</head>
<body>
  <h2>TSP: Dramatic Classical vs Quantum-Inspired Demo</h2>
  <small>
    Click to add a location. Drag to move it. Set a start node.
    Use the dramatic demo buttons to visualize why the Traveling Salesperson Problem becomes hard.
  </small>

  <div class="row">
    <div>
      <canvas id="map" width="900" height="600" aria-label="Map canvas"></canvas>
    </div>

    <div class="panel">
      <label>
        Floorplan image file (default: SVVSDMap.png)
        <input id="imgPath" value="SVVSDMap.png" />
      </label>
      <button id="loadImg">Load / Reload floorplan</button>

      <label>
        Start node index (0-based)
        <input id="startIndex" type="number" value="0" min="0" />
      </label>

      <div class="grid2">
        <button id="toggleGraph">Toggle: Show connections</button>
        <button id="toggleComplexity">Toggle: Show route complexity</button>
      </div>

      <div class="sectionTitle">Dramatic Demos (no instant mode)</div>

      <button id="runClassical">Run Classical Exploration (Dramatic)</button>
      <button id="runQuantum">Run Quantum Speedup Demo (Dramatic)</button>
      <button id="stopRun">Stop / Cancel</button>

      <div class="dangerNote">
        <b>Important note for students:</b><br/>
        The “computation time” shown below is <b>simulated and exaggerated</b> for learning/visual impact.
        Everything here runs on a classical computer in your browser. The “quantum” mode is a <b>quantum-inspired visualization</b>
        (probabilistic sampling / energy minimization), not actual quantum hardware performance.
      </div>

      <button id="clearRoute">Clear Route (keep points)</button>
      <button id="resetAll">Reset All</button>

      <div class="stat" id="stats">Route: —<br/>Distance: —</div>
      <div class="hint" id="statusMsg"></div>
      <div class="stat" id="timing">
        <b>Computation time (simulated)</b><br/>
        Classical: —<br/>
        Quantum: —<br/>
        <small class="hint">Wall-clock (your machine): —</small>
      </div>

      <h3>Export / Import</h3>
      <button id="export">Export JSON</button>
      <button id="import">Import JSON</button>
      <textarea id="jsonBox" placeholder='{"points":[{"name":"A","x":100,"y":120}, ...]}'></textarea>

      <small class="hint">
        Teaching move: toggle complexity overlay and add points one-by-one. Students will watch tours explode factorially.
      </small>
    </div>
  </div>

<script>
(() => {
  // ---------- Calibration ----------
  // 1882.1 px corresponds to 49.9 miles (known reference route)
  const MILES_PER_PIXEL = 49.9 / 1882.1;

  // ---------- Drama knobs ----------
  // These are intentionally exaggerated delays/effort for the "feel" of computation.
  const CLASSICAL_STEP_DELAY_MS = 120;   // slow + visible
  const CLASSICAL_ROUTE_TEST_DELAY_MS = 40; // per test "attempt" in exploration
  const QUANTUM_STEP_DELAY_MS = 8;       // fast + punchy

  // How many "route tests" the dramatic classical exploration performs.
  // This is NOT literal (n-1)! unless n is tiny; it's a dramatized sample that scales with complexity.
  const CLASSICAL_TESTS_PER_POINT = 800; // increase for more drama (also more waiting)

  // For tiny n, we can do real brute force (still animated), but we don't rely on it for drama.
  const REAL_BRUTE_FORCE_MAX_N = 10;

  // ---------- State ----------
  const canvas = document.getElementById("map");
  const ctx = canvas.getContext("2d");
  const img = new Image();

  let points = [];         // {name, x, y}
  let route = null;        // array of indices e.g. [0,3,2,1,0]
  let draggingIndex = -1;

  let showCompleteGraph = false;
  let showComplexityOverlay = true;

  let isRunning = false;
  let cancelToken = 0;

  // timing metrics
  let simulatedClassicalMs = null;
  let simulatedQuantumMs = null;
  let wallClockMs = null;

  // ---------- Helpers ----------
  const dist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);

  function routeLength(routeIdxs) {
    if (!routeIdxs || routeIdxs.length < 2) return 0;
    let total = 0;
    for (let i = 0; i < routeIdxs.length - 1; i++) {
      total += dist(points[routeIdxs[i]], points[routeIdxs[i+1]]);
    }
    return total;
  }

  function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }

  function setStatus(msg) {
    document.getElementById("statusMsg").textContent = msg || "";
  }

  function clampStartIndex() {
    const input = document.getElementById("startIndex");
    const n = points.length;
    if (n === 0) { input.value = 0; return 0; }
    let v = parseInt(input.value, 10);
    if (Number.isNaN(v)) v = 0;
    v = Math.max(0, Math.min(n - 1, v));
    input.value = v;
    return v;
  }

  function edgesCount(n) { return (n * (n - 1)) / 2; }

  // Approx tours (fix start): (n-1)! shown in scientific-ish notation (via log10)
  function factorialLog10(k) {
    if (k < 2) return 0;
    let s = 0;
    for (let i = 2; i <= k; i++) s += Math.log10(i);
    return s;
  }
  function formatFactorial(k) {
    if (k < 2) return "1";
    const log10v = factorialLog10(k);
    const exp = Math.floor(log10v);
    const mant = Math.pow(10, log10v - exp);
    if (exp < 6) {
      let v = 1;
      for (let i = 2; i <= k; i++) v *= i;
      return v.toLocaleString();
    }
    return `${mant.toFixed(3)} × 10^${exp}`;
  }

  function drawCompleteGraph() {
    const n = points.length;
    if (n < 2) return;
    ctx.lineWidth = 1;
    ctx.strokeStyle = "rgba(0,0,0,0.12)";
    for (let i = 0; i < n; i++) {
      for (let j = i + 1; j < n; j++) {
        ctx.beginPath();
        ctx.moveTo(points[i].x, points[i].y);
        ctx.lineTo(points[j].x, points[j].y);
        ctx.stroke();
      }
    }
  }

  function drawRoute() {
    if (!route || route.length < 2) return;
    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(0,0,0,0.78)";
    ctx.beginPath();
    const p0 = points[route[0]];
    ctx.moveTo(p0.x, p0.y);
    for (let i = 1; i < route.length; i++) {
      const p = points[route[i]];
      ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();
  }

  function drawComplexityOverlay() {
    if (!showComplexityOverlay) return;
    const n = points.length;
    const edges = edgesCount(n);
    const tours = formatFactorial(Math.max(0, n - 1));

    const boxX = 14, boxY = 14, boxW = 460, boxH = 92;
    ctx.fillStyle = "rgba(255,255,255,0.86)";
    ctx.fillRect(boxX, boxY, boxW, boxH);
    ctx.strokeStyle = "rgba(0,0,0,0.15)";
    ctx.strokeRect(boxX, boxY, boxW, boxH);

    ctx.fillStyle = "rgba(0,0,0,0.86)";
    ctx.font = "14px system-ui, Arial";
    ctx.fillText(`Points (n): ${n}`, boxX + 12, boxY + 24);

    ctx.font = "13px system-ui, Arial";
    ctx.fillText(`Connections (edges): n(n−1)/2 = ${edges.toLocaleString()} (quadratic)`, boxX + 12, boxY + 46);

    ctx.fillText(`Routes (tours, fix start): (n−1)! ≈ ${tours} (factorial explosion)`, boxX + 12, boxY + 68);

    ctx.fillStyle = "rgba(0,0,0,0.58)";
    ctx.font = "12px system-ui, Arial";
    ctx.fillText(`Edges are not exponential. Routes are factorial (worse than exponential).`, boxX + 12, boxY + 88);
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (img.complete && img.naturalWidth) {
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    } else {
      ctx.fillStyle = "#fafafa";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#888";
      ctx.fillText("No floorplan loaded (set image path and click Load)", 16, 24);
    }

    if (showCompleteGraph) drawCompleteGraph();
    drawRoute();

    const start = clampStartIndex();
    points.forEach((p, i) => {
      ctx.beginPath();
      ctx.fillStyle = (i === start) ? "rgba(0,150,0,0.9)" : "rgba(0,90,200,0.9)";
      ctx.arc(p.x, p.y, 10, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = "12px system-ui, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(String(i), p.x, p.y);

      ctx.fillStyle = "rgba(0,0,0,0.85)";
      ctx.textAlign = "left";
      ctx.textBaseline = "alphabetic";
      ctx.fillText(p.name ?? `Room ${i}`, p.x + 14, p.y - 12);
    });

    drawComplexityOverlay();
    updateStats();
    updateTimingBox();
  }

  function updateStats(meta = {}) {
    const el = document.getElementById("stats");
    if (!route) {
      el.innerHTML = `Route: —<br/>Distance: —`;
      return;
    }
    const names = route.map(i => points[i]?.name ?? `#${i}`).join(" → ");
    const pxDistance = routeLength(route);
    const miles = pxDistance * MILES_PER_PIXEL;

    const metaParts = [];
    if (meta.mode) metaParts.push(`<span class="pill">${meta.mode}</span>`);
    if (typeof meta.states === "number") metaParts.push(`<span class="pill">states: ${meta.states.toLocaleString()}</span>`);

    el.innerHTML = `
      Route:<br/>
      <small>${names}</small><br/>
      Distance: <strong>${miles.toFixed(2)} miles</strong>
      <br/><small>(${pxDistance.toFixed(1)} px)</small>
      ${metaParts.length ? `<div style="margin-top:6px">${metaParts.join(" ")}</div>` : ""}
    `;
  }

  function updateTimingBox() {
    const el = document.getElementById("timing");
    const c = (simulatedClassicalMs == null) ? "—" : `${(simulatedClassicalMs/1000).toFixed(2)} s`;
    const q = (simulatedQuantumMs == null) ? "—" : `${(simulatedQuantumMs/1000).toFixed(2)} s`;
    const w = (wallClockMs == null) ? "—" : `${(wallClockMs/1000).toFixed(2)} s`;

    el.innerHTML = `
      <b>Computation time (simulated)</b><br/>
      Classical: <span class="mono">${c}</span><br/>
      Quantum: <span class="mono">${q}</span><br/>
      <small class="hint">Wall-clock (your machine): <span class="mono">${w}</span></small>
      <br/><small class="hint">Note: simulated values are exaggerated for visualization; not real hardware benchmarks.</small>
    `;
  }

  function ensureNotRunning() {
    if (isRunning) {
      setStatus("A demo is already running. Press Stop/Cancel first.");
      return false;
    }
    return true;
  }

  function beginRun(msg) {
    isRunning = true;
    cancelToken++;
    setStatus(msg || "Running...");
    // reset timing for each run
    simulatedClassicalMs = null;
    simulatedQuantumMs = null;
    wallClockMs = null;
    return cancelToken;
  }

  function endRun(msg) {
    isRunning = false;
    setStatus(msg || "");
  }

  function wasCancelled(token) {
    return token !== cancelToken;
  }

  // ---------- Core building blocks ----------
  function nearestNeighborStepRoute(startIdx, visited, partial) {
    const n = points.length;
    const last = partial[partial.length - 1];
    let best = -1;
    let bestD = Infinity;
    for (let i = 0; i < n; i++) {
      if (!visited[i]) {
        const d = dist(points[last], points[i]);
        if (d < bestD) { bestD = d; best = i; }
      }
    }
    return best;
  }

  async function greedyAnimated(startIdx, token) {
    const n = points.length;
    const visited = Array(n).fill(false);
    const r = [startIdx];
    visited[startIdx] = true;

    route = r.slice();
    updateStats({ mode: "Classical: Greedy (animated)", states: 1 });
    draw();

    for (let step = 1; step < n; step++) {
      if (wasCancelled(token)) return null;
      const best = nearestNeighborStepRoute(startIdx, visited, r);
      visited[best] = true;
      r.push(best);

      route = r.slice();
      updateStats({ mode: "Classical: Greedy (animated)", states: step + 1 });
      draw();

      await sleep(CLASSICAL_STEP_DELAY_MS);
    }

    r.push(startIdx);
    route = r.slice();
    updateStats({ mode: "Classical: Greedy (animated)", states: n });
    draw();
    return r;
  }

  function makeRandomRoute(startIdx) {
    const n = points.length;
    if (n === 0) return null;

    const remaining = [];
    for (let i = 0; i < n; i++) if (i !== startIdx) remaining.push(i);

    for (let i = remaining.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [remaining[i], remaining[j]] = [remaining[j], remaining[i]];
    }
    return [startIdx, ...remaining, startIdx];
  }

  function twoOptImproveOnce(r) {
    if (!r || r.length < 5) return r;
    let best = r.slice();
    let bestLen = routeLength(best);

    for (let i = 1; i < best.length - 3; i++) {
      for (let k = i + 1; k < best.length - 2; k++) {
        const candidate = best.slice();
        const segment = candidate.slice(i, k + 1).reverse();
        candidate.splice(i, k - i + 1, ...segment);
        const len = routeLength(candidate);
        if (len + 1e-9 < bestLen) {
          best = candidate;
          bestLen = len;
        }
      }
    }
    return best;
  }

  // ---------- Dramatic classical exploration ----------
  // This is the "watch it grind" phase that makes route complexity visible.
  // It samples many random routes (and sometimes 2-opt improves them) while updating best-so-far.
  async function classicalExplorationDramatic(startIdx, token) {
    const n = points.length;
    if (n < 3) return;

    const toursApprox = formatFactorial(Math.max(0, n - 1));
    const testsTarget = Math.max(600, n * CLASSICAL_TESTS_PER_POINT); // scales with n
    setStatus(`Classical exploration: sampling routes (dramatic). Tours explode to ~${toursApprox}. Testing ${testsTarget.toLocaleString()} candidate routes...`);

    let best = makeRandomRoute(startIdx);
    let bestLen = routeLength(best);

    let tested = 0;

    // batch processing for responsiveness
    const BATCH = 60;

    while (tested < testsTarget) {
      if (wasCancelled(token)) return;

      for (let b = 0; b < BATCH && tested < testsTarget; b++) {
        tested++;

        // generate a candidate route and occasionally apply one 2-opt improvement
        let cand = makeRandomRoute(startIdx);
        if (Math.random() < 0.35) cand = twoOptImproveOnce(cand);

        const candLen = routeLength(cand);
        if (candLen < bestLen) {
          best = cand;
          bestLen = candLen;
          route = best.slice();
        }
      }

      // Update visuals periodically (so students see movement)
      route = best.slice();
      updateStats({ mode: "Classical: Exploration (dramatic)", states: tested });
      draw();

      // Dramatic pause
      await sleep(CLASSICAL_ROUTE_TEST_DELAY_MS);
    }

    route = best.slice();
    updateStats({ mode: "Classical: Exploration (dramatic)", states: tested });
    draw();
  }

  // ---------- Optional real brute force (tiny N) ----------
  // Kept as "truth anchor" when n <= 10, but not required for the dramatic story.
  function* heapPermutations(arr) {
    const a = arr.slice();
    const n = a.length;
    const c = new Array(n).fill(0);
    yield a.slice();
    let i = 0;
    while (i < n) {
      if (c[i] < i) {
        if (i % 2 === 0) [a[0], a[i]] = [a[i], a[0]];
        else [a[c[i]], a[i]] = [a[i], a[c[i]]];
        yield a.slice();
        c[i] += 1;
        i = 0;
      } else {
        c[i] = 0;
        i += 1;
      }
    }
  }

  async function bruteForceAnimatedTiny(startIdx, token) {
    const n = points.length;
    if (n < 2) return;
    if (n > REAL_BRUTE_FORCE_MAX_N) return; // not running real brute force for big n

    const nodes = [];
    for (let i = 0; i < n; i++) if (i !== startIdx) nodes.push(i);

    let total = 1;
    for (let i = 2; i <= (n - 1); i++) total *= i;

    setStatus(`(Truth anchor) Brute force: evaluating ${(n-1)}! = ${formatFactorial(n-1)} tours (animated)...`);

    let best = null;
    let bestLen = Infinity;
    let tested = 0;

    const gen = heapPermutations(nodes);
    const BATCH = 200;

    while (true) {
      if (wasCancelled(token)) return;

      for (let b = 0; b < BATCH; b++) {
        const nx = gen.next();
        if (nx.done) {
          route = best;
          updateStats({ mode: "Classical: Brute Force (tiny n)", states: tested });
          draw();
          return;
        }

        tested++;
        const perm = nx.value;
        const cand = [startIdx, ...perm, startIdx];
        const len = routeLength(cand);
        if (len < bestLen) {
          bestLen = len;
          best = cand;
          route = best.slice();
        }
      }

      updateStats({ mode: "Classical: Brute Force (tiny n)", states: tested });
      draw();
      await sleep(CLASSICAL_ROUTE_TEST_DELAY_MS);
      if (tested >= total) break;
    }
  }

  // ---------- Quantum-inspired dramatic demo ----------
  // This is "sampling + energy bias" (annealing-ish) but with very fast, dramatic improvement steps.
  function proposeSwap(current) {
    const len = current.length;
    if (len <= 4) return current.slice();
    const i = 1 + Math.floor(Math.random() * (len - 2));
    let k = 1 + Math.floor(Math.random() * (len - 2));
    while (k === i) k = 1 + Math.floor(Math.random() * (len - 2));
    const next = current.slice();
    [next[i], next[k]] = [next[k], next[i]];
    return next;
  }

  async function quantumSpeedupDramatic(startIdx, token) {
    const n = points.length;
    if (n < 3) return;

    // "Quantum demo" does far fewer visible steps, but each step represents many hidden samples.
    // This is intentionally theatrical.
    const visibleSteps = 60;
    const hiddenSamplesPerStep = Math.max(200, n * 250); // increases with n
    const totalHiddenSamples = visibleSteps * hiddenSamplesPerStep;

    setStatus(`Quantum speedup demo (simulated): sampling many routes per step (dramatic). Visible steps: ${visibleSteps}, hidden samples/step: ${hiddenSamplesPerStep.toLocaleString()}.`);

    let best = makeRandomRoute(startIdx);
    let bestLen = routeLength(best);

    // "temperature" effect for early exploration
    let T = 50;

    for (let step = 1; step <= visibleSteps; step++) {
      if (wasCancelled(token)) return;

      // In each visible step, do a lot of hidden sampling quickly.
      // We bias acceptance to mimic energy-based search.
      for (let s = 0; s < hiddenSamplesPerStep; s++) {
        let cand = proposeSwap(best);
        // occasional 2-opt "kick" to create dramatic improvements
        if (Math.random() < 0.10) cand = twoOptImproveOnce(cand);

        const candLen = routeLength(cand);
        const delta = candLen - bestLen;

        // accept improvements or sometimes accept worse early (but since we keep "best" display, it feels fast)
        if (delta <= 0 || Math.random() < Math.exp(-delta / Math.max(1e-9, T))) {
          // Only update "best" if actually better (keeps the demo moving toward improvement)
          if (candLen < bestLen) {
            best = cand;
            bestLen = candLen;
          }
        }
      }

      T *= 0.92; // cool quickly for drama

      route = best.slice();
      updateStats({ mode: "Quantum demo (simulated)", states: step * hiddenSamplesPerStep });
      draw();

      await sleep(QUANTUM_STEP_DELAY_MS);
    }

    route = best.slice();
    updateStats({ mode: "Quantum demo (simulated)", states: totalHiddenSamples });
    draw();
  }

  // ---------- Orchestrators: the two big demo buttons ----------
  async function runClassicalDemo() {
    if (!ensureNotRunning()) return;
    if (points.length < 2) { setStatus("Add at least 2 points first."); return; }

    const token = beginRun("Classical demo starting...");
    const startWall = performance.now();

    const n = points.length;
    const tours = formatFactorial(Math.max(0, n - 1));

    // Simulated time: Greedy steps + route tests
    const greedySim = Math.max(1, n) * CLASSICAL_STEP_DELAY_MS;
    const testsTarget = Math.max(600, n * CLASSICAL_TESTS_PER_POINT);
    const exploreSim = testsTarget * CLASSICAL_ROUTE_TEST_DELAY_MS;
    simulatedClassicalMs = greedySim + exploreSim;

    // Quantum simulated time blank until quantum run
    simulatedQuantumMs = null;

    setStatus(`Classical demo: building a route greedily, then grinding through exploration. Routes grow to ~${tours}.`);
    await greedyAnimated(clampStartIndex(), token);
    if (wasCancelled(token)) return;

    await classicalExplorationDramatic(clampStartIndex(), token);
    if (wasCancelled(token)) return;

    // truth anchor brute force if tiny n
    if (points.length <= REAL_BRUTE_FORCE_MAX_N) {
      setStatus("Bonus truth anchor: brute force (tiny n) to show optimal best-so-far...");
      await bruteForceAnimatedTiny(clampStartIndex(), token);
      if (wasCancelled(token)) return;
    } else {
      setStatus(`Truth anchor skipped: real brute force is only practical for n ≤ ${REAL_BRUTE_FORCE_MAX_N}.`);
    }

    wallClockMs = performance.now() - startWall;
    endRun("Classical demo complete.");
    draw();
  }

  async function runQuantumDemo() {
    if (!ensureNotRunning()) return;
    if (points.length < 2) { setStatus("Add at least 2 points first."); return; }

    const token = beginRun("Quantum demo starting...");
    const startWall = performance.now();

    // Simulated time: much smaller (dramatic speedup)
    // We define it from visible steps and quantum delay
    const n = points.length;
    const visibleSteps = 60;
    const hiddenSamplesPerStep = Math.max(200, n * 250);

    simulatedQuantumMs = visibleSteps * QUANTUM_STEP_DELAY_MS;
    // If classical sim is not set (running quantum first), we still want a comparable classical estimate:
    if (simulatedClassicalMs == null) {
      const greedySim = Math.max(1, n) * CLASSICAL_STEP_DELAY_MS;
      const testsTarget = Math.max(600, n * CLASSICAL_TESTS_PER_POINT);
      const exploreSim = testsTarget * CLASSICAL_ROUTE_TEST_DELAY_MS;
      simulatedClassicalMs = greedySim + exploreSim;
    }

    setStatus("Quantum demo: showing a fast, dramatic ‘sampling toward low energy’ visualization.");
    await quantumSpeedupDramatic(clampStartIndex(), token);
    if (wasCancelled(token)) return;

    wallClockMs = performance.now() - startWall;
    endRun(`Quantum demo complete. (Simulated hidden samples: ${(visibleSteps * hiddenSamplesPerStep).toLocaleString()})`);
    draw();
  }

  // ---------- Events ----------
  function getMousePos(evt) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: (evt.clientX - rect.left) * (canvas.width / rect.width),
      y: (evt.clientY - rect.top) * (canvas.height / rect.height)
    };
  }

  canvas.addEventListener("mousedown", (evt) => {
    const m = getMousePos(evt);

    draggingIndex = -1;
    for (let i = points.length - 1; i >= 0; i--) {
      if (Math.hypot(points[i].x - m.x, points[i].y - m.y) <= 12) {
        draggingIndex = i;
        return;
      }
    }

    points.push({ name: `Location ${points.length}`, x: m.x, y: m.y });
    route = null;
    setStatus("");
    draw();
  });

  canvas.addEventListener("mousemove", (evt) => {
    if (draggingIndex < 0) return;
    const m = getMousePos(evt);
    points[draggingIndex].x = m.x;
    points[draggingIndex].y = m.y;
    draw();
  });

  window.addEventListener("mouseup", () => draggingIndex = -1);

  document.getElementById("toggleGraph").addEventListener("click", () => {
    showCompleteGraph = !showCompleteGraph;
    const n = points.length;
    setStatus(showCompleteGraph
      ? `Connections ON. Edges = n(n−1)/2 = ${edgesCount(n).toLocaleString()} (quadratic).`
      : "Connections OFF."
    );
    draw();
  });

  document.getElementById("toggleComplexity").addEventListener("click", () => {
    showComplexityOverlay = !showComplexityOverlay;
    setStatus(showComplexityOverlay ? "Route complexity overlay ON." : "Route complexity overlay OFF.");
    draw();
  });

  document.getElementById("runClassical").addEventListener("click", runClassicalDemo);
  document.getElementById("runQuantum").addEventListener("click", runQuantumDemo);

  document.getElementById("stopRun").addEventListener("click", () => {
    if (!isRunning) {
      setStatus("Nothing is currently running.");
      return;
    }
    cancelToken++;
    isRunning = false;
    setStatus("Cancelled. (You can run another demo now.)");
  });

  document.getElementById("clearRoute").addEventListener("click", () => {
    if (isRunning) { setStatus("Stop the demo first."); return; }
    route = null;
    setStatus("Route cleared (points kept).");
    draw();
  });

  document.getElementById("resetAll").addEventListener("click", () => {
    cancelToken++;
    isRunning = false;
    points = [];
    route = null;
    showCompleteGraph = false;
    showComplexityOverlay = true;
    simulatedClassicalMs = null;
    simulatedQuantumMs = null;
    wallClockMs = null;
    document.getElementById("startIndex").value = 0;
    setStatus("Reset complete.");
    draw();
  });

  document.getElementById("export").addEventListener("click", () => {
    document.getElementById("jsonBox").value = JSON.stringify({ points }, null, 2);
    setStatus("Exported points to JSON box.");
  });

  document.getElementById("import").addEventListener("click", () => {
    if (isRunning) { setStatus("Stop the demo first."); return; }
    try {
      const obj = JSON.parse(document.getElementById("jsonBox").value.trim());
      if (!Array.isArray(obj.points)) throw new Error("JSON must contain { points: [...] }");

      points = obj.points.map((p, i) => ({
        name: String(p.name ?? `Location ${i}`),
        x: Number(p.x),
        y: Number(p.y)
      }));

      route = null;
      setStatus("Imported points. Run Classical or Quantum demo.");
      draw();
    } catch (e) {
      alert("Import failed: " + e.message);
    }
  });

  document.getElementById("loadImg").addEventListener("click", () => {
    const path = document.getElementById("imgPath").value.trim() || "SVVSDMap.png";
    img.src = path + (path.includes("?") ? "&" : "?") + "v=" + Date.now();
    setStatus(`Loading image: ${path}`);
  });

  img.onload = () => { setStatus("Floorplan loaded."); draw(); };
  img.onerror = () => { setStatus("Could not load floorplan image. Check filename/case."); draw(); };

  // initial draw
  img.src = "SVVSDMap.png";
  draw();
})();
</script>
</body>
</html>
