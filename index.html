<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TSP Building Route Lab</title>
  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 16px; }
    .row { display: flex; gap: 16px; align-items: flex-start; flex-wrap: wrap; }
    .panel { min-width: 280px; max-width: 360px; }
    button, input { padding: 8px 10px; margin: 4px 0; width: 100%; }
    textarea { width: 100%; height: 160px; }
    canvas { border: 1px solid #ccc; border-radius: 8px; }
    small { color: #444; display: block; line-height: 1.35; }
    .stat { padding: 8px 10px; background: #f5f5f5; border-radius: 8px; margin-top: 8px; }
    .hint { font-size: 12px; color: #555; margin-top: 6px; }
  </style>
</head>
<body>
  <h2>TSP: Building Route Solver (Greedy + 2-opt + Random + Brute Force)</h2>
  <small>
    Click to add a location. Drag a location to move it. Set a start node, then solve.
    Distances are computed in pixels and converted to miles using a calibrated scale.
  </small>

  <div class="row">
    <div>
      <canvas id="map" width="900" height="600" aria-label="SVVSD map canvas"></canvas>
    </div>

    <div class="panel">
      <label>
        Floorplan image file (default: SVVSDMap.png)
        <input id="imgPath" value="SVVSDMap.png" />
      </label>
      <button id="loadImg">Load / Reload floorplan</button>

      <label>
        Start node index (0-based)
        <input id="startIndex" type="number" value="0" min="0" />
      </label>

      <button id="toggleGraph">Toggle: Show all connections (complete graph)</button>

      <button id="solveGreedy">Solve: Greedy Nearest Neighbor</button>
      <button id="randomRoute">Make: Random Route</button>
      <button id="improve2opt">Improve: 2-opt (20 passes)</button>
      <button id="bruteForce">Solve: Brute Force (Optimal, small N)</button>

      <button id="clearRoute">Clear Route (keep points)</button>
      <button id="resetAll">Reset All</button>

      <div class="stat" id="stats">Route: —<br/>Distance: —</div>
      <div class="hint" id="statusMsg"></div>

      <h3>Export / Import</h3>
      <button id="export">Export JSON</button>
      <button id="import">Import JSON</button>
      <textarea id="jsonBox" placeholder='{"points":[{"name":"A","x":100,"y":120}, ...]}'></textarea>

      <small>
        Tip: Rename nodes by editing JSON (name field). “Show all connections” is great for teaching
        how quickly the number of edges grows as you add points.
      </small>
    </div>
  </div>

<script>
(() => {
  // ---------- Calibration ----------
  // 1882.1 px corresponds to 49.9 miles (known reference route)
  const MILES_PER_PIXEL = 49.9 / 1882.1;

  // Brute force safety cap (factorial explosion!)
  const BRUTE_FORCE_MAX_N = 10;

  // ---------- State ----------
  const canvas = document.getElementById("map");
  const ctx = canvas.getContext("2d");
  const img = new Image();
  let points = [];         // {name, x, y}
  let route = null;        // array of indices e.g. [0,3,2,1,0]
  let draggingIndex = -1;
  let showCompleteGraph = false;

  // ---------- Helpers ----------
  const dist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);

  function routeLength(routeIdxs) {
    if (!routeIdxs || routeIdxs.length < 2) return 0;
    let total = 0;
    for (let i = 0; i < routeIdxs.length - 1; i++) {
      total += dist(points[routeIdxs[i]], points[routeIdxs[i+1]]);
    }
    return total;
  }

  function setStatus(msg) {
    document.getElementById("statusMsg").textContent = msg || "";
  }

  function clampStartIndex() {
    const input = document.getElementById("startIndex");
    const n = points.length;
    if (n === 0) { input.value = 0; return 0; }
    let v = parseInt(input.value, 10);
    if (Number.isNaN(v)) v = 0;
    v = Math.max(0, Math.min(n - 1, v));
    input.value = v;
    return v;
  }

  function drawCompleteGraph() {
    const n = points.length;
    if (n < 2) return;

    ctx.lineWidth = 1;
    ctx.strokeStyle = "rgba(0,0,0,0.12)";
    for (let i = 0; i < n; i++) {
      for (let j = i + 1; j < n; j++) {
        ctx.beginPath();
        ctx.moveTo(points[i].x, points[i].y);
        ctx.lineTo(points[j].x, points[j].y);
        ctx.stroke();
      }
    }
  }

  function drawRoute() {
    if (!route || route.length < 2) return;

    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(0,0,0,0.75)";
    ctx.beginPath();
    const p0 = points[route[0]];
    ctx.moveTo(p0.x, p0.y);
    for (let i = 1; i < route.length; i++) {
      const p = points[route[i]];
      ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (img.complete && img.naturalWidth) {
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    } else {
      ctx.fillStyle = "#fafafa";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#888";
      ctx.fillText("No floorplan loaded (set image path and click Load)", 16, 24);
    }

    // Optional complete graph behind everything
    if (showCompleteGraph) drawCompleteGraph();

    // Route on top of the graph lines
    drawRoute();

    // Points
    const start = clampStartIndex();
    points.forEach((p, i) => {
      ctx.beginPath();
      ctx.fillStyle = (i === start) ? "rgba(0,150,0,0.9)" : "rgba(0,90,200,0.9)";
      ctx.arc(p.x, p.y, 10, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = "12px system-ui, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(String(i), p.x, p.y);

      ctx.fillStyle = "rgba(0,0,0,0.85)";
      ctx.textAlign = "left";
      ctx.textBaseline = "alphabetic";
      ctx.fillText(p.name ?? `Room ${i}`, p.x + 14, p.y - 12);
    });

    updateStats();
  }

  function updateStats() {
    const el = document.getElementById("stats");
    if (!route) {
      el.innerHTML = `Route: —<br/>Distance: —`;
      return;
    }
    const names = route.map(i => points[i]?.name ?? `#${i}`).join(" → ");
    const pxDistance = routeLength(route);
    const miles = pxDistance * MILES_PER_PIXEL;

    el.innerHTML = `
      Route:<br/>
      <small>${names}</small><br/>
      Distance: <strong>${miles.toFixed(2)} miles</strong>
      <br/><small>(${pxDistance.toFixed(1)} px)</small>
    `;
  }

  // ---------- Solvers ----------
  function nearestNeighbor(startIdx) {
    const n = points.length;
    if (n === 0) return null;

    const visited = Array(n).fill(false);
    const r = [startIdx];
    visited[startIdx] = true;

    for (let step = 1; step < n; step++) {
      const last = r[r.length - 1];
      let best = -1;
      let bestD = Infinity;

      for (let i = 0; i < n; i++) {
        if (!visited[i]) {
          const d = dist(points[last], points[i]);
          if (d < bestD) { bestD = d; best = i; }
        }
      }
      visited[best] = true;
      r.push(best);
    }

    r.push(startIdx);
    return r;
  }

  // 2-opt improvement for a cycle route
  function twoOptImprove(r, passes = 20) {
    if (!r || r.length < 5) return { route: r, improved: false, delta: 0 };

    let best = r.slice();
    let bestLen = routeLength(best);
    let improvedAny = false;

    for (let pass = 0; pass < passes; pass++) {
      let improvedThisPass = false;

      for (let i = 1; i < best.length - 3; i++) {
        for (let k = i + 1; k < best.length - 2; k++) {
          const candidate = best.slice();
          const segment = candidate.slice(i, k + 1).reverse();
          candidate.splice(i, k - i + 1, ...segment);

          const len = routeLength(candidate);
          if (len + 1e-9 < bestLen) {
            best = candidate;
            bestLen = len;
            improvedThisPass = true;
            improvedAny = true;
          }
        }
      }

      if (!improvedThisPass) break;
    }

    const originalLen = routeLength(r);
    return { route: best, improved: improvedAny, delta: originalLen - bestLen };
  }

  function makeRandomRoute(startIdx) {
    const n = points.length;
    if (n === 0) return null;

    const remaining = [];
    for (let i = 0; i < n; i++) if (i !== startIdx) remaining.push(i);

    // Fisher-Yates shuffle
    for (let i = remaining.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [remaining[i], remaining[j]] = [remaining[j], remaining[i]];
    }

    const r = [startIdx, ...remaining, startIdx];
    return r;
  }

  // Brute force optimal (fix start index, permute the rest)
  function bruteForceOptimal(startIdx) {
    const n = points.length;
    if (n < 2) return null;

    const nodes = [];
    for (let i = 0; i < n; i++) if (i !== startIdx) nodes.push(i);

    let bestRoute = null;
    let bestLen = Infinity;

    // Heap's algorithm for permutations (iterative-ish recursion)
    function permute(a, k) {
      if (k === 1) {
        const candidate = [startIdx, ...a, startIdx];
        const len = routeLength(candidate);
        if (len < bestLen) {
          bestLen = len;
          bestRoute = candidate;
        }
        return;
      }
      permute(a, k - 1);
      for (let i = 0; i < k - 1; i++) {
        if (k % 2 === 0) {
          [a[i], a[k - 1]] = [a[k - 1], a[i]];
        } else {
          [a[0], a[k - 1]] = [a[k - 1], a[0]];
        }
        permute(a, k - 1);
      }
    }

    permute(nodes.slice(), nodes.length);
    return bestRoute;
  }

  // ---------- Events ----------
  function getMousePos(evt) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: (evt.clientX - rect.left) * (canvas.width / rect.width),
      y: (evt.clientY - rect.top) * (canvas.height / rect.height)
    };
  }

  canvas.addEventListener("mousedown", (evt) => {
    const m = getMousePos(evt);

    draggingIndex = -1;
    for (let i = points.length - 1; i >= 0; i--) {
      if (Math.hypot(points[i].x - m.x, points[i].y - m.y) <= 12) {
        draggingIndex = i;
        return;
      }
    }

    points.push({ name: `Location ${points.length}`, x: m.x, y: m.y });
    route = null;
    setStatus("");
    draw();
  });

  canvas.addEventListener("mousemove", (evt) => {
    if (draggingIndex < 0) return;
    const m = getMousePos(evt);
    points[draggingIndex].x = m.x;
    points[draggingIndex].y = m.y;
    setStatus("");
    draw();
  });

  window.addEventListener("mouseup", () => draggingIndex = -1);

  document.getElementById("toggleGraph").addEventListener("click", () => {
    showCompleteGraph = !showCompleteGraph;
    const n = points.length;
    const edges = (n * (n - 1)) / 2;
    setStatus(showCompleteGraph
      ? `Complete graph ON. With ${n} points, that’s ${edges} connections.`
      : "Complete graph OFF."
    );
    draw();
  });

  document.getElementById("solveGreedy").addEventListener("click", () => {
    const start = clampStartIndex();
    route = nearestNeighbor(start);
    setStatus("Greedy route created. Try 2-opt to remove crossings / shorten it.");
    draw();
  });

  document.getElementById("randomRoute").addEventListener("click", () => {
    const start = clampStartIndex();
    route = makeRandomRoute(start);
    setStatus("Random route created. Try 2-opt or Greedy to compare improvement.");
    draw();
  });

  document.getElementById("improve2opt").addEventListener("click", () => {
    if (!route) {
      setStatus("No route yet. Create one with Greedy or Random first.");
      return;
    }
    const before = routeLength(route);
    const result = twoOptImprove(route, 20);
    route = result.route;
    const after = routeLength(route);

    if (!result.improved) {
      setStatus("2-opt ran: no improvement found (route may already be locally optimal).");
    } else {
      const savedPx = before - after;
      const savedMiles = savedPx * MILES_PER_PIXEL;
      setStatus(`2-opt improved the route! Saved ${savedMiles.toFixed(2)} miles (${savedPx.toFixed(1)} px).`);
    }
    draw();
  });

  document.getElementById("bruteForce").addEventListener("click", () => {
    const n = points.length;
    if (n === 0) return;

    if (n > BRUTE_FORCE_MAX_N) {
      setStatus(`Brute force blocked: ${n} points is too many. Limit is ${BRUTE_FORCE_MAX_N}. (Factorial blow-up)`);
      return;
    }

    const start = clampStartIndex();
    setStatus(`Brute forcing optimal route for ${n} points...`);
    // Give the browser a beat to paint status text before heavy work
    setTimeout(() => {
      const best = bruteForceOptimal(start);
      route = best;
      setStatus(`Brute force complete: optimal route found for ${n} points. Compare vs Greedy/2-opt.`);
      draw();
    }, 10);
  });

  document.getElementById("clearRoute").addEventListener("click", () => {
    route = null;
    setStatus("Route cleared (points kept).");
    draw();
  });

  document.getElementById("resetAll").addEventListener("click", () => {
    points = [];
    route = null;
    showCompleteGraph = false;
    document.getElementById("startIndex").value = 0;
    setStatus("Reset complete.");
    draw();
  });

  document.getElementById("export").addEventListener("click", () => {
    document.getElementById("jsonBox").value = JSON.stringify({ points }, null, 2);
    setStatus("Exported points to JSON box.");
  });

  document.getElementById("import").addEventListener("click", () => {
    try {
      const obj = JSON.parse(document.getElementById("jsonBox").value.trim());
      if (!Array.isArray(obj.points)) throw new Error("JSON must contain { points: [...] }");

      points = obj.points.map((p, i) => ({
        name: String(p.name ?? `Location ${i}`),
        x: Number(p.x),
        y: Number(p.y)
      }));

      route = null;
      setStatus("Imported points. Create a route with Greedy/Random/Brute Force.");
      draw();
    } catch (e) {
      alert("Import failed: " + e.message);
    }
  });

  document.getElementById("loadImg").addEventListener("click", () => {
    const path = document.getElementById("imgPath").value.trim() || "SVVSDMap.png";
    img.src = path + (path.includes("?") ? "&" : "?") + "v=" + Date.now();
    setStatus(`Loading image: ${path}`);
  });

  img.onload = () => { setStatus("Floorplan loaded."); draw(); };
  img.onerror = () => { setStatus("Could not load floorplan image. Check filename/case."); draw(); };

  // initial draw
  img.src = "SVVSDMap.png";
  draw();
})();
</script>
</body>
</html>
