<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TSP Building Route Lab (Dramatic Classical vs Quantum Demo)</title>
  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 16px; }
    .row { display: flex; gap: 16px; align-items: flex-start; flex-wrap: wrap; }
    .panel { min-width: 320px; max-width: 440px; }
    button, input { padding: 8px 10px; margin: 4px 0; width: 100%; box-sizing: border-box; }
    textarea { width: 100%; height: 160px; box-sizing: border-box; }
    canvas { border: 1px solid #ccc; border-radius: 8px; }
    small { color: #444; display: block; line-height: 1.35; }
    .stat { padding: 10px 12px; background: #f5f5f5; border-radius: 8px; margin-top: 8px; }
    .hint { font-size: 12px; color: #555; margin-top: 6px; }
    .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .sectionTitle { margin-top: 12px; font-weight: 700; }
    .pill { display:inline-block; padding: 2px 8px; border-radius: 999px; background:#eee; font-size: 12px; }
    .dangerNote { font-size: 12px; color: #333; background: #fff7d6; border: 1px solid #ead48a; padding: 10px; border-radius: 8px; margin-top: 8px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
  </style>
</head>
<body>
  <h2>TSP: Dramatic Classical vs Quantum-Inspired Demo</h2>
  <small>
    Click to add a location. Drag to move it. Set a start node.
    The complexity overlay focuses on <b>routes/tours</b> (factorial explosion), not just edges (quadratic).
  </small>

  <div class="row">
    <div>
      <canvas id="map" width="900" height="600" aria-label="Map canvas"></canvas>
    </div>

    <div class="panel">
      <label>
        Floorplan image file (default: SVVSDMap.png)
        <input id="imgPath" value="SVVSDMap.png" />
      </label>
      <button id="loadImg">Load / Reload floorplan</button>

      <label>
        Start node index (0-based)
        <input id="startIndex" type="number" value="0" min="0" />
      </label>

      <div class="grid2">
        <button id="toggleGraph">Toggle: Show connections</button>
        <button id="toggleComplexity">Toggle: Show route complexity</button>
      </div>

      <div class="sectionTitle">Dramatic Demos</div>

      <div class="grid2">
        <button id="runRandomCuration">Random Route Curation (Dramatic)</button>
        <button id="runClassical">Classical Demo (Dramatic)</button>
      </div>
      <button id="runQuantum">Quantum Speedup Demo (Dramatic)</button>
      <button id="stopRun">Stop / Cancel</button>

      <div class="dangerNote">
        <b>Important note for students:</b><br/>
        The “computation time” shown below is <b>simulated and exaggerated</b> for learning/visual impact.
        Everything here runs on a classical computer in your browser. The “quantum” mode is a <b>quantum-inspired visualization</b>
        (probabilistic sampling / energy minimization), not actual quantum hardware performance.
      </div>

      <button id="clearRoute">Clear Route (keep points)</button>
      <button id="resetAll">Reset All</button>

      <div class="stat" id="stats">Route: —<br/>Distance: —</div>
      <div class="hint" id="statusMsg"></div>

      <div class="stat" id="timing">
        <b>Computation time (simulated)</b><br/>
        Classical: —<br/>
        Quantum: —<br/>
        <small class="hint">Wall-clock (your machine): —</small>
      </div>

      <h3>Export / Import</h3>
      <button id="export">Export JSON</button>
      <button id="import">Import JSON</button>
      <textarea id="jsonBox" placeholder='{"points":[{"name":"A","x":100,"y":120}, ...]}'></textarea>

      <small class="hint">
        Teaching move: add points one-by-one while the complexity overlay is ON.
      </small>
    </div>
  </div>

<script>
(() => {
  // ---------- Calibration ----------
  const MILES_PER_PIXEL = 49.9 / 1882.1;

  // ---------- Timing / Drama knobs ----------
  // Target: classical demo ~20–40 seconds for typical classroom N
  const GREEDY_STEP_DELAY_MS = 90;      // step-by-step visible, but not forever
  const CURATION_SHOW_DELAY_MS = 140;   // show a few ugly random routes quickly

  // Exploration work:
  // We do MANY tests, but only redraw occasionally, and we do large batches per "frame"
  const CLASSICAL_TOTAL_TESTS_BASE = 7000;    // base tests
  const CLASSICAL_TESTS_PER_POINT = 900;      // scales with n
  const CLASSICAL_BATCH_SIZE = 400;           // tests per UI update chunk
  const CLASSICAL_UPDATE_EVERY_CHUNK_MS = 40; // pause between redraws (drama pacing)

  // Quantum demo: fast & punchy
  const QUANTUM_VISIBLE_STEPS = 55;
  const QUANTUM_STEP_DELAY_MS = 10;
  const QUANTUM_SAMPLES_PER_STEP_BASE = 800; // hidden work per visible step
  const QUANTUM_SAMPLES_PER_POINT = 260;

  // Optional truth anchor brute force cap
  const REAL_BRUTE_FORCE_MAX_N = 10;

  // ---------- State ----------
  const canvas = document.getElementById("map");
  const ctx = canvas.getContext("2d");
  const img = new Image();

  let points = [];
  let route = null;
  let draggingIndex = -1;

  let showCompleteGraph = false;
  let showComplexityOverlay = true;

  let isRunning = false;
  let cancelToken = 0;

  // timing metrics
  let simulatedClassicalMs = null;
  let simulatedQuantumMs = null;
  let wallClockMs = null;

  // ---------- Helpers ----------
  const dist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);

  function routeLength(routeIdxs) {
    if (!routeIdxs || routeIdxs.length < 2) return 0;
    let total = 0;
    for (let i = 0; i < routeIdxs.length - 1; i++) {
      total += dist(points[routeIdxs[i]], points[routeIdxs[i+1]]);
    }
    return total;
  }

  function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }

  function setStatus(msg) {
    document.getElementById("statusMsg").textContent = msg || "";
  }

  function clampStartIndex() {
    const input = document.getElementById("startIndex");
    const n = points.length;
    if (n === 0) { input.value = 0; return 0; }
    let v = parseInt(input.value, 10);
    if (Number.isNaN(v)) v = 0;
    v = Math.max(0, Math.min(n - 1, v));
    input.value = v;
    return v;
  }

  function edgesCount(n) { return (n * (n - 1)) / 2; }

  function factorialLog10(k) {
    if (k < 2) return 0;
    let s = 0;
    for (let i = 2; i <= k; i++) s += Math.log10(i);
    return s;
  }
  function formatFactorial(k) {
    if (k < 2) return "1";
    const log10v = factorialLog10(k);
    const exp = Math.floor(log10v);
    const mant = Math.pow(10, log10v - exp);
    if (exp < 6) {
      let v = 1;
      for (let i = 2; i <= k; i++) v *= i;
      return v.toLocaleString();
    }
    return `${mant.toFixed(3)} × 10^${exp}`;
  }

  function drawCompleteGraph() {
    const n = points.length;
    if (n < 2) return;
    ctx.lineWidth = 1;
    ctx.strokeStyle = "rgba(0,0,0,0.12)";
    for (let i = 0; i < n; i++) {
      for (let j = i + 1; j < n; j++) {
        ctx.beginPath();
        ctx.moveTo(points[i].x, points[i].y);
        ctx.lineTo(points[j].x, points[j].y);
        ctx.stroke();
      }
    }
  }

  function drawRoute() {
    if (!route || route.length < 2) return;
    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(0,0,0,0.78)";
    ctx.beginPath();
    const p0 = points[route[0]];
    ctx.moveTo(p0.x, p0.y);
    for (let i = 1; i < route.length; i++) {
      const p = points[route[i]];
      ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();
  }

  function drawComplexityOverlay() {
    if (!showComplexityOverlay) return;
    const n = points.length;
    const edges = edgesCount(n);
    const tours = formatFactorial(Math.max(0, n - 1));

    const boxX = 14, boxY = 14, boxW = 490, boxH = 92;
    ctx.fillStyle = "rgba(255,255,255,0.86)";
    ctx.fillRect(boxX, boxY, boxW, boxH);
    ctx.strokeStyle = "rgba(0,0,0,0.15)";
    ctx.strokeRect(boxX, boxY, boxW, boxH);

    ctx.fillStyle = "rgba(0,0,0,0.86)";
    ctx.font = "14px system-ui, Arial";
    ctx.fillText(`Points (n): ${n}`, boxX + 12, boxY + 24);

    ctx.font = "13px system-ui, Arial";
    ctx.fillText(`Edges: n(n−1)/2 = ${edges.toLocaleString()} (quadratic)`, boxX + 12, boxY + 46);

    ctx.fillText(`Possible routes: (n−1)! ≈ ${tours} (factorial explosion)`, boxX + 12, boxY + 68);

    ctx.fillStyle = "rgba(0,0,0,0.58)";
    ctx.font = "12px system-ui, Arial";
    ctx.fillText(`The hard part is routes/tours, not edges.`, boxX + 12, boxY + 88);
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (img.complete && img.naturalWidth) {
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    } else {
      ctx.fillStyle = "#fafafa";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#888";
      ctx.fillText("No floorplan loaded (set image path and click Load)", 16, 24);
    }

    if (showCompleteGraph) drawCompleteGraph();
    drawRoute();

    const start = clampStartIndex();
    points.forEach((p, i) => {
      ctx.beginPath();
      ctx.fillStyle = (i === start) ? "rgba(0,150,0,0.9)" : "rgba(0,90,200,0.9)";
      ctx.arc(p.x, p.y, 10, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = "12px system-ui, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(String(i), p.x, p.y);

      ctx.fillStyle = "rgba(0,0,0,0.85)";
      ctx.textAlign = "left";
      ctx.textBaseline = "alphabetic";
      ctx.fillText(p.name ?? `Room ${i}`, p.x + 14, p.y - 12);
    });

    drawComplexityOverlay();
    updateStats();
    updateTimingBox();
  }

  function updateStats(meta = {}) {
    const el = document.getElementById("stats");
    if (!route) {
      el.innerHTML = `Route: —<br/>Distance: —`;
      return;
    }
    const names = route.map(i => points[i]?.name ?? `#${i}`).join(" → ");
    const pxDistance = routeLength(route);
    const miles = pxDistance * MILES_PER_PIXEL;

    const metaParts = [];
    if (meta.mode) metaParts.push(`<span class="pill">${meta.mode}</span>`);
    if (typeof meta.states === "number") metaParts.push(`<span class="pill">states: ${meta.states.toLocaleString()}</span>`);

    el.innerHTML = `
      Route:<br/>
      <small>${names}</small><br/>
      Distance: <strong>${miles.toFixed(2)} miles</strong>
      <br/><small>(${pxDistance.toFixed(1)} px)</small>
      ${metaParts.length ? `<div style="margin-top:6px">${metaParts.join(" ")}</div>` : ""}
    `;
  }

  function updateTimingBox() {
    const el = document.getElementById("timing");
    const c = (simulatedClassicalMs == null) ? "—" : `${(simulatedClassicalMs/1000).toFixed(2)} s`;
    const q = (simulatedQuantumMs == null) ? "—" : `${(simulatedQuantumMs/1000).toFixed(2)} s`;
    const w = (wallClockMs == null) ? "—" : `${(wallClockMs/1000).toFixed(2)} s`;

    el.innerHTML = `
      <b>Computation time (simulated)</b><br/>
      Classical: <span class="mono">${c}</span><br/>
      Quantum: <span class="mono">${q}</span><br/>
      <small class="hint">Wall-clock (your machine): <span class="mono">${w}</span></small>
      <br/><small class="hint">Simulated values are exaggerated for visualization; not real hardware benchmarks.</small>
    `;
  }

  function ensureNotRunning() {
    if (isRunning) {
      setStatus("A demo is already running. Press Stop/Cancel first.");
      return false;
    }
    return true;
  }

  function beginRun(msg) {
    isRunning = true;
    cancelToken++;
    setStatus(msg || "Running...");
    // reset timing per run
    simulatedClassicalMs = null;
    simulatedQuantumMs = null;
    wallClockMs = null;
    return cancelToken;
  }

  function endRun(msg) {
    isRunning = false;
    setStatus(msg || "");
  }

  function wasCancelled(token) {
    return token !== cancelToken;
  }

  // ---------- Route tools ----------
  function makeRandomRoute(startIdx) {
    const n = points.length;
    if (n === 0) return null;

    const remaining = [];
    for (let i = 0; i < n; i++) if (i !== startIdx) remaining.push(i);

    for (let i = remaining.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [remaining[i], remaining[j]] = [remaining[j], remaining[i]];
    }
    return [startIdx, ...remaining, startIdx];
  }

  function twoOptImproveOnce(r) {
    if (!r || r.length < 5) return r;
    let best = r.slice();
    let bestLen = routeLength(best);

    for (let i = 1; i < best.length - 3; i++) {
      for (let k = i + 1; k < best.length - 2; k++) {
        const cand = best.slice();
        const seg = cand.slice(i, k + 1).reverse();
        cand.splice(i, k - i + 1, ...seg);
        const len = routeLength(cand);
        if (len + 1e-9 < bestLen) {
          best = cand;
          bestLen = len;
        }
      }
    }
    return best;
  }

  async function greedyAnimated(startIdx, token) {
    const n = points.length;
    const visited = Array(n).fill(false);
    const r = [startIdx];
    visited[startIdx] = true;

    route = r.slice();
    updateStats({ mode: "Classical: Greedy build", states: 1 });
    draw();
    await sleep(GREEDY_STEP_DELAY_MS);

    for (let step = 1; step < n; step++) {
      if (wasCancelled(token)) return null;
      const last = r[r.length - 1];
      let best = -1;
      let bestD = Infinity;

      for (let i = 0; i < n; i++) {
        if (!visited[i]) {
          const d = dist(points[last], points[i]);
          if (d < bestD) { bestD = d; best = i; }
        }
      }

      visited[best] = true;
      r.push(best);

      route = r.slice();
      updateStats({ mode: "Classical: Greedy build", states: step + 1 });
      draw();
      await sleep(GREEDY_STEP_DELAY_MS);
    }

    r.push(startIdx);
    route = r.slice();
    updateStats({ mode: "Classical: Greedy build", states: n });
    draw();
    return r;
  }

  // ---------- NEW: Random route curation (dramatic baseline) ----------
  // Shows ugly random routes, keeps a best-so-far, and ends on the best one.
  async function randomRouteCurationDramatic(startIdx, token, rounds = 16) {
    if (points.length < 3) return null;

    setStatus("Random route curation: generating messy routes and keeping the best-so-far...");

    let best = null;
    let bestLen = Infinity;

    for (let i = 1; i <= rounds; i++) {
      if (wasCancelled(token)) return null;

      const cand = makeRandomRoute(startIdx);
      route = cand; // show the messy one on purpose
      updateStats({ mode: "Random curation (candidate)", states: i });
      draw();
      await sleep(CURATION_SHOW_DELAY_MS);

      const len = routeLength(cand);
      if (len < bestLen) {
        best = cand;
        bestLen = len;
      }
    }

    // End on the best random found
    route = best;
    updateStats({ mode: "Random curation (best found)", states: rounds });
    draw();
    setStatus("Random route curation complete: best random route shown.");
    return best;
  }

  // ---------- Classical exploration (monotonic best-only) ----------
  // Key fix: we NEVER draw worse routes once a best exists.
  async function classicalExplorationMonotonic(startIdx, token) {
    const n = points.length;
    if (n < 3) return;

    const testsTarget = Math.max(CLASSICAL_TOTAL_TESTS_BASE, n * CLASSICAL_TESTS_PER_POINT);

    setStatus(
      `Classical improvement: testing many candidate routes (best-so-far only). ` +
      `This is a dramatized “exploration” stand-in for brute force. Candidates: ${testsTarget.toLocaleString()}.`
    );

    // Start from current route (greedy) if present, otherwise best random
    let best = route ? route.slice() : makeRandomRoute(startIdx);
    let bestLen = routeLength(best);

    let tested = 0;

    while (tested < testsTarget) {
      if (wasCancelled(token)) return;

      // do a big batch quickly
      for (let b = 0; b < CLASSICAL_BATCH_SIZE && tested < testsTarget; b++) {
        tested++;

        // make candidate by random + occasional 2-opt polishing
        let cand = makeRandomRoute(startIdx);
        if (Math.random() < 0.55) cand = twoOptImproveOnce(cand);

        const candLen = routeLength(cand);
        if (candLen < bestLen) {
          best = cand;
          bestLen = candLen;
        }
      }

      // show only best-so-far (monotonic)
      route = best.slice();
      updateStats({ mode: "Classical: Best-so-far exploration", states: tested });
      draw();

      // small pacing delay so it feels like computation
      await sleep(CLASSICAL_UPDATE_EVERY_CHUNK_MS);
    }

    route = best.slice();
    updateStats({ mode: "Classical: Best-so-far exploration", states: tested });
    draw();
    setStatus("Classical improvement complete (best-so-far displayed).");
  }

  // ---------- Quantum demo (fast improvement, best-only) ----------
  function proposeSwap(current) {
    const len = current.length;
    if (len <= 4) return current.slice();
    const i = 1 + Math.floor(Math.random() * (len - 2));
    let k = 1 + Math.floor(Math.random() * (len - 2));
    while (k === i) k = 1 + Math.floor(Math.random() * (len - 2));
    const next = current.slice();
    [next[i], next[k]] = [next[k], next[i]];
    return next;
  }

  async function quantumSpeedupDramatic(startIdx, token) {
    const n = points.length;
    if (n < 3) return;

    const hiddenSamplesPerStep = Math.max(QUANTUM_SAMPLES_PER_STEP_BASE, n * QUANTUM_SAMPLES_PER_POINT);
    const totalHidden = QUANTUM_VISIBLE_STEPS * hiddenSamplesPerStep;

    setStatus(
      `Quantum speedup demo (simulated): lots of hidden sampling per step, fast best-route improvements. ` +
      `Hidden samples/step: ${hiddenSamplesPerStep.toLocaleString()}.`
    );

    let best = route ? route.slice() : makeRandomRoute(startIdx);
    let bestLen = routeLength(best);

    let T = 55; // fast-cooling for drama

    for (let step = 1; step <= QUANTUM_VISIBLE_STEPS; step++) {
      if (wasCancelled(token)) return;

      for (let s = 0; s < hiddenSamplesPerStep; s++) {
        let cand = proposeSwap(best);
        if (Math.random() < 0.12) cand = twoOptImproveOnce(cand); // occasional “jump”

        const candLen = routeLength(cand);
        const delta = candLen - bestLen;

        // Accept exploration sometimes, but we only keep if better (best-only display)
        if (delta <= 0 || Math.random() < Math.exp(-delta / Math.max(1e-9, T))) {
          if (candLen < bestLen) {
            best = cand;
            bestLen = candLen;
          }
        }
      }

      T *= 0.90;

      route = best.slice();
      updateStats({ mode: "Quantum demo (simulated)", states: step * hiddenSamplesPerStep });
      draw();

      await sleep(QUANTUM_STEP_DELAY_MS);
    }

    route = best.slice();
    updateStats({ mode: "Quantum demo (simulated)", states: totalHidden });
    draw();
    setStatus("Quantum demo complete: best-so-far shown.");
  }

  // ---------- Truth anchor brute force (tiny n) ----------
  function* heapPermutations(arr) {
    const a = arr.slice();
    const n = a.length;
    const c = new Array(n).fill(0);
    yield a.slice();
    let i = 0;
    while (i < n) {
      if (c[i] < i) {
        if (i % 2 === 0) [a[0], a[i]] = [a[i], a[0]];
        else [a[c[i]], a[i]] = [a[i], a[c[i]]];
        yield a.slice();
        c[i] += 1;
        i = 0;
      } else {
        c[i] = 0;
        i += 1;
      }
    }
  }

  async function bruteForceTinyBestOnly(startIdx, token) {
    const n = points.length;
    if (n > REAL_BRUTE_FORCE_MAX_N || n < 2) return;

    const nodes = [];
    for (let i = 0; i < n; i++) if (i !== startIdx) nodes.push(i);

    let best = null;
    let bestLen = Infinity;
    let tested = 0;

    const gen = heapPermutations(nodes);
    const BATCH = 250;
    setStatus(`(Truth anchor) brute force for tiny n: evaluating ${(n-1)}! = ${formatFactorial(n-1)} tours...`);

    while (true) {
      if (wasCancelled(token)) return;

      for (let b = 0; b < BATCH; b++) {
        const nx = gen.next();
        if (nx.done) {
          route = best;
          updateStats({ mode: "Truth anchor: brute force (tiny n)", states: tested });
          draw();
          setStatus("(Truth anchor) brute force complete: optimal route shown.");
          return;
        }

        tested++;
        const cand = [startIdx, ...nx.value, startIdx];
        const len = routeLength(cand);
        if (len < bestLen) {
          bestLen = len;
          best = cand;
        }
      }

      route = best;
      updateStats({ mode: "Truth anchor: brute force (tiny n)", states: tested });
      draw();
      await sleep(35);
    }
  }

  // ---------- Orchestrators ----------
  async function runRandomCuration() {
    if (!ensureNotRunning()) return;
    if (points.length < 3) { setStatus("Add at least 3 points for random curation to be meaningful."); return; }

    const token = beginRun("Random route curation starting...");
    const startWall = performance.now();

    // simulated time: rounds * delay
    const rounds = 16;
    simulatedClassicalMs = rounds * CURATION_SHOW_DELAY_MS;
    simulatedQuantumMs = null;

    await randomRouteCurationDramatic(clampStartIndex(), token, rounds);
    if (wasCancelled(token)) return;

    wallClockMs = performance.now() - startWall;
    endRun("Random route curation complete.");
    draw();
  }

  async function runClassicalDemo() {
    if (!ensureNotRunning()) return;
    if (points.length < 2) { setStatus("Add at least 2 points first."); return; }

    const token = beginRun("Classical demo starting...");
    const startWall = performance.now();
    const n = points.length;

    // Estimate simulated classical time:
    const testsTarget = Math.max(CLASSICAL_TOTAL_TESTS_BASE, n * CLASSICAL_TESTS_PER_POINT);
    simulatedClassicalMs =
      (Math.max(1, n) * GREEDY_STEP_DELAY_MS) +
      (Math.ceil(testsTarget / CLASSICAL_BATCH_SIZE) * CLASSICAL_UPDATE_EVERY_CHUNK_MS) +
      (16 * CURATION_SHOW_DELAY_MS);

    simulatedQuantumMs = null;

    // 1) show random baseline curation (so students see "bad" first)
    await randomRouteCurationDramatic(clampStartIndex(), token, 16);
    if (wasCancelled(token)) return;

    // 2) greedy build
    setStatus("Classical demo: Greedy builds a reasonable route quickly (but not always best).");
    await greedyAnimated(clampStartIndex(), token);
    if (wasCancelled(token)) return;

    // 3) best-only exploration (monotonic)
    await classicalExplorationMonotonic(clampStartIndex(), token);
    if (wasCancelled(token)) return;

    // optional truth anchor for tiny n
    if (points.length <= REAL_BRUTE_FORCE_MAX_N) {
      await bruteForceTinyBestOnly(clampStartIndex(), token);
      if (wasCancelled(token)) return;
    } else {
      setStatus(`Classical demo complete. (Truth anchor skipped: brute force only feasible for n ≤ ${REAL_BRUTE_FORCE_MAX_N}.)`);
    }

    wallClockMs = performance.now() - startWall;
    endRun("Classical demo complete.");
    draw();
  }

  async function runQuantumDemo() {
    if (!ensureNotRunning()) return;
    if (points.length < 2) { setStatus("Add at least 2 points first."); return; }

    const token = beginRun("Quantum demo starting...");
    const startWall = performance.now();
    const n = points.length;

    // Ensure classical estimate exists for comparison
    if (simulatedClassicalMs == null) {
      const testsTarget = Math.max(CLASSICAL_TOTAL_TESTS_BASE, n * CLASSICAL_TESTS_PER_POINT);
      simulatedClassicalMs =
        (Math.max(1, n) * GREEDY_STEP_DELAY_MS) +
        (Math.ceil(testsTarget / CLASSICAL_BATCH_SIZE) * CLASSICAL_UPDATE_EVERY_CHUNK_MS) +
        (16 * CURATION_SHOW_DELAY_MS);
    }

    // Simulated quantum time: visible steps * delay
    simulatedQuantumMs = QUANTUM_VISIBLE_STEPS * QUANTUM_STEP_DELAY_MS;

    // Start from a random baseline quickly (no long curation here—quantum is “fast”)
    route = makeRandomRoute(clampStartIndex());
    updateStats({ mode: "Quantum demo (starting point)" });
    draw();
    await sleep(120);

    await quantumSpeedupDramatic(clampStartIndex(), token);
    if (wasCancelled(token)) return;

    wallClockMs = performance.now() - startWall;
    endRun("Quantum demo complete.");
    draw();
  }

  // ---------- Canvas interaction ----------
  function getMousePos(evt) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: (evt.clientX - rect.left) * (canvas.width / rect.width),
      y: (evt.clientY - rect.top) * (canvas.height / rect.height)
    };
  }

  canvas.addEventListener("mousedown", (evt) => {
    const m = getMousePos(evt);
    draggingIndex = -1;
    for (let i = points.length - 1; i >= 0; i--) {
      if (Math.hypot(points[i].x - m.x, points[i].y - m.y) <= 12) {
        draggingIndex = i;
        return;
      }
    }
    points.push({ name: `Location ${points.length}`, x: m.x, y: m.y });
    route = null;
    setStatus("");
    draw();
  });

  canvas.addEventListener("mousemove", (evt) => {
    if (draggingIndex < 0) return;
    const m = getMousePos(evt);
    points[draggingIndex].x = m.x;
    points[draggingIndex].y = m.y;
    draw();
  });

  window.addEventListener("mouseup", () => draggingIndex = -1);

  // ---------- Buttons ----------
  document.getElementById("toggleGraph").addEventListener("click", () => {
    showCompleteGraph = !showCompleteGraph;
    const n = points.length;
    setStatus(showCompleteGraph
      ? `Connections ON. Edges = n(n−1)/2 = ${edgesCount(n).toLocaleString()} (quadratic).`
      : "Connections OFF."
    );
    draw();
  });

  document.getElementById("toggleComplexity").addEventListener("click", () => {
    showComplexityOverlay = !showComplexityOverlay;
    setStatus(showComplexityOverlay ? "Route complexity overlay ON." : "Route complexity overlay OFF.");
    draw();
  });

  document.getElementById("runRandomCuration").addEventListener("click", runRandomCuration);
  document.getElementById("runClassical").addEventListener("click", runClassicalDemo);
  document.getElementById("runQuantum").addEventListener("click", runQuantumDemo);

  document.getElementById("stopRun").addEventListener("click", () => {
    if (!isRunning) { setStatus("Nothing is currently running."); return; }
    cancelToken++;
    isRunning = false;
    setStatus("Cancelled. (You can run another demo now.)");
  });

  document.getElementById("clearRoute").addEventListener("click", () => {
    if (isRunning) { setStatus("Stop the demo first."); return; }
    route = null;
    setStatus("Route cleared (points kept).");
    draw();
  });

  document.getElementById("resetAll").addEventListener("click", () => {
    cancelToken++;
    isRunning = false;
    points = [];
    route = null;
    showCompleteGraph = false;
    showComplexityOverlay = true;
    simulatedClassicalMs = null;
    simulatedQuantumMs = null;
    wallClockMs = null;
    document.getElementById("startIndex").value = 0;
    setStatus("Reset complete.");
    draw();
  });

  // export/import
  document.getElementById("export").addEventListener("click", () => {
    document.getElementById("jsonBox").value = JSON.stringify({ points }, null, 2);
    setStatus("Exported points to JSON box.");
  });

  document.getElementById("import").addEventListener("click", () => {
    if (isRunning) { setStatus("Stop the demo first."); return; }
    try {
      const obj = JSON.parse(document.getElementById("jsonBox").value.trim());
      if (!Array.isArray(obj.points)) throw new Error("JSON must contain { points: [...] }");
      points = obj.points.map((p, i) => ({
        name: String(p.name ?? `Location ${i}`),
        x: Number(p.x),
        y: Number(p.y)
      }));
      route = null;
      setStatus("Imported points. Run a demo.");
      draw();
    } catch (e) {
      alert("Import failed: " + e.message);
    }
  });

  // image load
  document.getElementById("loadImg").addEventListener("click", () => {
    const path = document.getElementById("imgPath").value.trim() || "SVVSDMap.png";
    img.src = path + (path.includes("?") ? "&" : "?") + "v=" + Date.now();
    setStatus(`Loading image: ${path}`);
  });

  img.onload = () => { setStatus("Floorplan loaded."); draw(); };
  img.onerror = () => { setStatus("Could not load floorplan image. Check filename/case."); draw(); };

  img.src = "SVVSDMap.png";
  draw();
})();
</script>
</body>
</html>
